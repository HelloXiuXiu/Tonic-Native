var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/@socketsupply/tonic/index.js
var TonicTemplate = class {
  constructor(rawText, templateStrings, unsafe) {
    this.isTonicTemplate = true;
    this.unsafe = unsafe;
    this.rawText = rawText;
    this.templateStrings = templateStrings;
  }
  valueOf() {
    return this.rawText;
  }
  toString() {
    return this.rawText;
  }
};
var _Tonic = class _Tonic extends window.HTMLElement {
  // eslint-disable-next-line no-undef
  static get version() {
    return "15.1.2";
  }
  static get SPREAD() {
    return /\.\.\.\s?(__\w+__\w+__)/g;
  }
  static get ESC() {
    return /["&'<>`/]/g;
  }
  static get AsyncFunctionGenerator() {
    return (async function* () {
    }).constructor;
  }
  static get AsyncFunction() {
    return (async function() {
    }).constructor;
  }
  static get MAP() {
    return { '"': "&quot;", "&": "&amp;", "'": "&#x27;", "<": "&lt;", ">": "&gt;", "`": "&#x60;", "/": "&#x2F;" };
  }
  constructor() {
    super();
    const state = _Tonic._states[super.id];
    delete _Tonic._states[super.id];
    this._state = state || {};
    this.preventRenderOnReconnect = false;
    this.props = {};
    this.elements = [...this.children];
    this.elements.__children__ = true;
    this.nodes = [...this.childNodes];
    this.nodes.__children__ = true;
    this._events();
  }
  get isTonicComponent() {
    return true;
  }
  static _createId() {
    return `tonic${_Tonic._index++}`;
  }
  static _normalizeAttrs(o, x = {}) {
    [...o].forEach((o2) => x[o2.name] = o2.value);
    return x;
  }
  _checkId() {
    const _id = super.id;
    if (!_id) {
      const html = this.outerHTML.replace(this.innerHTML, "...");
      throw new Error(`Component: ${html} has no id`);
    }
    return _id;
  }
  get state() {
    return this._checkId(), this._state;
  }
  set state(newState) {
    this._state = (this._checkId(), newState);
  }
  _events() {
    const hp = Object.getOwnPropertyNames(window.HTMLElement.prototype);
    for (const p of this._props) {
      if (hp.indexOf("on" + p) === -1)
        continue;
      this.addEventListener(p, this);
    }
  }
  _prop(o) {
    const id = this._id;
    const p = `__${id}__${_Tonic._createId()}__`;
    _Tonic._data[id] = _Tonic._data[id] || {};
    _Tonic._data[id][p] = o;
    return p;
  }
  _placehold(r) {
    const id = this._id;
    const ref = `placehold:${id}:${_Tonic._createId()}__`;
    _Tonic._children[id] = _Tonic._children[id] || {};
    _Tonic._children[id][ref] = r;
    return ref;
  }
  static match(el, s) {
    if (!el.matches)
      el = el.parentElement;
    return el.matches(s) ? el : el.closest(s);
  }
  static getTagName(camelName) {
    return camelName.match(/[A-Z][a-z0-9]*/g).join("-").toLowerCase();
  }
  static getPropertyNames(proto) {
    const props = [];
    while (proto && proto !== _Tonic.prototype) {
      props.push(...Object.getOwnPropertyNames(proto));
      proto = Object.getPrototypeOf(proto);
    }
    return props;
  }
  static add(c, htmlName) {
    const hasValidName = htmlName || c.name && c.name.length > 1;
    if (!hasValidName) {
      throw Error("Mangling. https://bit.ly/2TkJ6zP");
    }
    if (!htmlName)
      htmlName = _Tonic.getTagName(c.name);
    if (!_Tonic.ssr && window.customElements.get(htmlName)) {
      throw new Error(`Cannot Tonic.add(${c.name}, '${htmlName}') twice`);
    }
    if (!c.prototype || !c.prototype.isTonicComponent) {
      const tmp = { [c.name]: class extends _Tonic {
      } }[c.name];
      tmp.prototype.render = c;
      c = tmp;
    }
    c.prototype._props = _Tonic.getPropertyNames(c.prototype);
    _Tonic._reg[htmlName] = c;
    _Tonic._tags = Object.keys(_Tonic._reg).join();
    window.customElements.define(htmlName, c);
    if (typeof c.stylesheet === "function") {
      _Tonic.registerStyles(c.stylesheet);
    }
    return c;
  }
  static registerStyles(stylesheetFn) {
    if (_Tonic._stylesheetRegistry.includes(stylesheetFn))
      return;
    _Tonic._stylesheetRegistry.push(stylesheetFn);
    const styleNode = document.createElement("style");
    if (_Tonic.nonce)
      styleNode.setAttribute("nonce", _Tonic.nonce);
    styleNode.appendChild(document.createTextNode(stylesheetFn()));
    if (document.head)
      document.head.appendChild(styleNode);
  }
  static escape(s) {
    return s.replace(_Tonic.ESC, (c) => _Tonic.MAP[c]);
  }
  static unsafeRawString(s, templateStrings) {
    return new TonicTemplate(s, templateStrings, true);
  }
  dispatch(eventName, detail = null) {
    const opts = { bubbles: true, detail };
    this.dispatchEvent(new window.CustomEvent(eventName, opts));
  }
  html(strings, ...values) {
    const refs = (o) => {
      if (o && o.__children__)
        return this._placehold(o);
      if (o && o.isTonicTemplate)
        return o.rawText;
      switch (Object.prototype.toString.call(o)) {
        case "[object HTMLCollection]":
        case "[object NodeList]":
          return this._placehold([...o]);
        case "[object Array]": {
          if (o.every((x) => x.isTonicTemplate && !x.unsafe)) {
            return new TonicTemplate(o.join("\n"), null, false);
          }
          return this._prop(o);
        }
        case "[object Object]":
        case "[object Function]":
        case "[object AsyncFunction]":
        case "[object Set]":
        case "[object Map]":
        case "[object WeakMap]":
          return this._prop(o);
        case "[object NamedNodeMap]":
          return this._prop(_Tonic._normalizeAttrs(o));
        case "[object Number]":
          return `${o}__float`;
        case "[object String]":
          return _Tonic.escape(o);
        case "[object Boolean]":
          return `${o}__boolean`;
        case "[object Null]":
          return `${o}__null`;
        case "[object HTMLElement]":
          return this._placehold([o]);
      }
      if (typeof o === "object" && o && o.nodeType === 1 && typeof o.cloneNode === "function") {
        return this._placehold([o]);
      }
      return o;
    };
    const out = [];
    for (let i = 0; i < strings.length - 1; i++) {
      out.push(strings[i], refs(values[i]));
    }
    out.push(strings[strings.length - 1]);
    const htmlStr = out.join("").replace(_Tonic.SPREAD, (_, p) => {
      const o = _Tonic._data[p.split("__")[1]][p];
      return Object.entries(o).map(([key, value]) => {
        const k = key.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
        if (value === true)
          return k;
        else if (value)
          return `${k}="${_Tonic.escape(String(value))}"`;
        else
          return "";
      }).filter(Boolean).join(" ");
    });
    return new TonicTemplate(htmlStr, strings, false);
  }
  scheduleReRender(oldProps) {
    if (this.pendingReRender)
      return this.pendingReRender;
    this.pendingReRender = new Promise((resolve) => setTimeout(() => {
      if (!this.isInDocument(this.shadowRoot || this))
        return;
      const p = this._set(this.shadowRoot || this, this.render);
      this.pendingReRender = null;
      if (p && p.then) {
        return p.then(() => {
          this.updated && this.updated(oldProps);
          resolve(this);
        });
      }
      this.updated && this.updated(oldProps);
      resolve(this);
    }, 0));
    return this.pendingReRender;
  }
  reRender(o = this.props) {
    const oldProps = { ...this.props };
    this.props = typeof o === "function" ? o(oldProps) : o;
    return this.scheduleReRender(oldProps);
  }
  handleEvent(e) {
    this[e.type](e);
  }
  _drainIterator(target, iterator) {
    return iterator.next().then((result) => {
      this._set(target, null, result.value);
      if (result.done)
        return;
      return this._drainIterator(target, iterator);
    });
  }
  _set(target, render, content = "") {
    this.willRender && this.willRender();
    for (const node of target.querySelectorAll(_Tonic._tags)) {
      if (!node.isTonicComponent)
        continue;
      const id = node.getAttribute("id");
      if (!id || !_Tonic._refIds.includes(id))
        continue;
      _Tonic._states[id] = node.state;
    }
    if (render instanceof _Tonic.AsyncFunction) {
      return render.call(this, this.html, this.props).then((content2) => this._apply(target, content2));
    } else if (render instanceof _Tonic.AsyncFunctionGenerator) {
      return this._drainIterator(target, render.call(this));
    } else if (render === null) {
      this._apply(target, content);
    } else if (render instanceof Function) {
      this._apply(target, render.call(this, this.html, this.props) || "");
    }
  }
  _apply(target, content) {
    if (content && content.isTonicTemplate) {
      content = content.rawText;
    } else if (typeof content === "string") {
      content = _Tonic.escape(content);
    }
    if (typeof content === "string") {
      if (this.stylesheet) {
        content = `<style nonce=${_Tonic.nonce || ""}>${this.stylesheet()}</style>${content}`;
      }
      target.innerHTML = content;
      if (this.styles) {
        const styles = this.styles();
        for (const node of target.querySelectorAll("[styles]")) {
          for (const s of node.getAttribute("styles").split(/\s+/)) {
            Object.assign(node.style, styles[s.trim()]);
          }
        }
      }
      const children = _Tonic._children[this._id] || {};
      const walk = (node, fn) => {
        if (node.nodeType === 3) {
          const id = node.textContent.trim();
          if (children[id])
            fn(node, children[id], id);
        }
        const childNodes = node.childNodes;
        if (!childNodes)
          return;
        for (let i = 0; i < childNodes.length; i++) {
          walk(childNodes[i], fn);
        }
      };
      walk(target, (node, children2, id) => {
        for (const child of children2) {
          node.parentNode.insertBefore(child, node);
        }
        delete _Tonic._children[this._id][id];
        node.parentNode.removeChild(node);
      });
    } else {
      target.innerHTML = "";
      target.appendChild(content.cloneNode(true));
    }
  }
  connectedCallback() {
    this.root = this.shadowRoot || this;
    if (super.id && !_Tonic._refIds.includes(super.id)) {
      _Tonic._refIds.push(super.id);
    }
    const cc = (s) => s.replace(/-(.)/g, (_, m) => m.toUpperCase());
    for (const { name: _name, value } of this.attributes) {
      const name = cc(_name);
      const p = this.props[name] = value;
      if (/__\w+__\w+__/.test(p)) {
        const { 1: root } = p.split("__");
        this.props[name] = _Tonic._data[root][p];
      } else if (/\d+__float/.test(p)) {
        this.props[name] = parseFloat(p, 10);
      } else if (p === "null__null") {
        this.props[name] = null;
      } else if (/\w+__boolean/.test(p)) {
        this.props[name] = p.includes("true");
      } else if (/placehold:\w+:\w+__/.test(p)) {
        const { 1: root } = p.split(":");
        this.props[name] = _Tonic._children[root][p][0];
      }
    }
    this.props = Object.assign(
      this.defaults ? this.defaults() : {},
      this.props
    );
    this._id = this._id || _Tonic._createId();
    this.willConnect && this.willConnect();
    if (!this.isInDocument(this.root))
      return;
    if (!this.preventRenderOnReconnect) {
      if (!this._source) {
        this._source = this.innerHTML;
      } else {
        this.innerHTML = this._source;
      }
      const p = this._set(this.root, this.render);
      if (p && p.then)
        return p.then(() => this.connected && this.connected());
    }
    this.connected && this.connected();
  }
  isInDocument(target) {
    const root = target.getRootNode();
    return root === document || root.toString() === "[object ShadowRoot]";
  }
  disconnectedCallback() {
    this.disconnected && this.disconnected();
    delete _Tonic._data[this._id];
    delete _Tonic._children[this._id];
  }
};
__publicField(_Tonic, "_tags", "");
__publicField(_Tonic, "_refIds", []);
__publicField(_Tonic, "_data", {});
__publicField(_Tonic, "_states", {});
__publicField(_Tonic, "_children", {});
__publicField(_Tonic, "_reg", {});
__publicField(_Tonic, "_stylesheetRegistry", []);
__publicField(_Tonic, "_index", 0);
var Tonic = _Tonic;
var tonic_default = Tonic;
export {
  Tonic,
  tonic_default as default
};
//# sourceMappingURL=@socketsupply_tonic.js.map
